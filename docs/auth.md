# Authentication Spec

## Overview

Google OAuth authentication using Better Auth with organization-scoped LiveStore sync.

```
User → Google OAuth → Better Auth → Session + JWT → LiveStore (org-scoped)
```

## Architecture

| Component | Purpose |
|-----------|---------|
| Better Auth | OAuth, sessions, JWT issuance (`jwt` + `organization` plugins) |
| D1 | Auth tables: user, session, account, verification, jwks, organization, member, invitation |
| jose | JWT verification via JWKS (from `auth.handler`) |
| LiveStore | Org-scoped stores using `{organizationId}` as storeId |

## Files

| File | Purpose |
|------|---------|
| `src/cf-worker/auth.ts` | Better Auth config with jwt + organization plugins |
| `src/cf-worker/index.ts` | Worker routes + JWT/org validation |
| `src/cf-worker/db/schema.ts` | Drizzle schema (auth + org tables) |
| `src/lib/auth.ts` | Auth client + `fetchAuth()` helper |
| `src/router.tsx` | Router with auth context type |
| `src/routes/__root.tsx` | `beforeLoad` auth check + redirect |
| `src/livestore/store.ts` | `useAppStore` with JWT from route context |

## Auth Flow

### 1. Signup (Google OAuth)

```
Click "Sign in" → Google OAuth → Better Auth callback
                                       │
                         ┌─────────────┴─────────────┐
                         │ user.create.after hook    │
                         │ → Creates personal org    │
                         │ → Adds user as owner      │
                         └─────────────┬─────────────┘
                                       │
                         ┌─────────────┴─────────────┐
                         │ session.create.before     │
                         │ → Sets activeOrgId        │
                         └─────────────┬─────────────┘
                                       │
                         Set session cookie + redirect
```

### 2. Route Protection (TanStack Router)

Auth checked in `beforeLoad`, not during render:

```typescript
// src/routes/__root.tsx
beforeLoad: async ({ location }) => {
  const auth = await fetchAuth()
  if (!auth.isAuthenticated && location.pathname !== '/login') {
    throw redirect({ to: '/login' })
  }
  return { auth }
}
```

### 3. LiveStore Sync Connection

```
useAppStore() → WebSocket /sync?storeId={orgId}&payload={jwt}
                                       │
                         ┌─────────────┴─────────────┐
                         │ validatePayload()         │
                         │ → Verify JWT via JWKS     │
                         │ → Check claims.orgId      │
                         │   matches storeId         │
                         └─────────────┬─────────────┘
                                       │
                              Connection accepted
```

## Token Strategy

| Token | Lifetime | Storage | Purpose |
|-------|----------|---------|---------|
| Session cookie | 7 days | HttpOnly cookie | Maintain login, refresh JWT |
| JWT | 1 hour | Route context | Sync auth (stateless validation) |

### JWT Signing

JWTs use **asymmetric EdDSA Ed25519 keys**, not `BETTER_AUTH_SECRET`:

- Key pairs auto-generated by Better Auth and stored in D1 `jwks` table
- JWT signed with **private key**
- JWT verified with **public key** via `auth.handler('/api/auth/jwks')`
- `BETTER_AUTH_SECRET` is only used for session cookie encryption

Note: `validatePayload` calls `auth.handler()` internally to fetch JWKS, avoiding external HTTP calls while staying coupled to Better Auth's public API (not DB schema).

## API Endpoints

### Better Auth (handled by `auth.handler`)

- `POST /api/auth/sign-in/social` - Google OAuth initiation
- `GET /api/auth/callback/google` - OAuth callback
- `GET /api/auth/get-session` - Get current session
- `POST /api/auth/token` - Get JWT
- `GET /api/auth/jwks` - Public keys for JWT verification
- `POST /api/auth/sign-up/email` - Email signup (test env only)

### Custom Endpoints

#### `GET /api/auth/me`

Returns current authenticated user with organization info.

```typescript
// Response 200
{
  user: { id, name, email },
  session: { activeOrganizationId },
  organization: { id, name, slug } | null
}

// Response 401
{ error: "Unauthorized" }
```

#### `GET /api/org/:id`

Returns organization if user is a member.

```typescript
// Response 200 (member)
{ id, name, slug, role }

// Response 403 (not member)
{ error: "Access denied" }

// Response 404 (not found)
{ error: "Organization not found" }
```

## Environment Variables

| Variable | Description |
|----------|-------------|
| `GOOGLE_CLIENT_ID` | Google OAuth client ID |
| `GOOGLE_CLIENT_SECRET` | Google OAuth client secret |
| `BETTER_AUTH_SECRET` | Secret for signing (32+ chars) |
| `BETTER_AUTH_URL` | Base URL (e.g., `http://localhost:3000`) |
| `ENABLE_TEST_AUTH` | Set to `"true"` to enable email signup (tests only) |

## Database Schema

### Auth Tables (Better Auth)

- `user` - id, name, email, emailVerified, image, timestamps
- `session` - id, token, userId, activeOrganizationId, timestamps
- `account` - OAuth provider links
- `verification` - Email verification tokens
- `jwks` - JWT signing keys

### Organization Tables

- `organization` - id, name, slug, logo, metadata, createdAt
- `member` - id, organizationId, userId, role, createdAt
- `invitation` - id, organizationId, email, role, status, expiresAt

## E2E Testing

### Setup

Tests use `@cloudflare/vitest-pool-workers` with isolated D1 database.

```bash
bun run test:e2e    # Run e2e tests
bun run test:unit   # Run unit tests
```

### Test Environment

- `ENABLE_TEST_AUTH=true` enables email/password signup
- Fresh in-memory D1 per test run (no effect on local dev DB)
- Migrations loaded from `drizzle/migrations/` and applied before tests

### Configuration

The `vitest.e2e.config.ts`:

1. **Loads migrations** from drizzle files in Node.js context
2. **Passes migrations** to Workers via `TEST_MIGRATIONS` binding
3. **Bundles dependencies** via `ssr.noExternal` for tree-shaking

```typescript
// Load migrations in Node.js context
const migrations = journal.entries.map((entry) => ({
  tag: entry.tag,
  sql: fs.readFileSync(`drizzle/migrations/${entry.tag}.sql`, 'utf-8'),
}))

export default defineWorkersConfig({
  // ...
  miniflare: {
    bindings: {
      TEST_MIGRATIONS: JSON.stringify(migrations),
    },
  },
  ssr: {
    noExternal: ['effect', /@effect\//, /@livestore\//, /@opentelemetry\//],
  },
})
```

### Test Files

```
src/cf-worker/__tests__/
├── e2e/
│   ├── auth.test.ts    # Auth endpoint tests
│   ├── sync.test.ts    # LiveStore sync auth tests
│   └── setup.ts        # Applies migrations from TEST_MIGRATIONS binding
├── unit/               # Unit tests
└── env.d.ts            # Type declarations (ProvidedEnv)
```

### Auth Test Cases (auth.test.ts)

| Test | Expected |
|------|----------|
| `GET /api/auth/me` (no auth) | 401 Unauthorized |
| `GET /api/auth/me` (with cookie) | 200 + user data |
| `GET /api/org/{myOrgId}` | 200 + org data |
| `GET /api/org/{otherOrgId}` | 403 Access denied |
| `GET /api/org/{nonExistent}` | 404 Not found |
| User A and B have different orgs | Isolated |

### Sync Test Cases (sync.test.ts)

| Test | Expected |
|------|----------|
| Sync without payload | 400 (schema validation) |
| Sync with empty payload | 400 (authToken missing) |
| Sync with malformed JWT | 400 (Invalid Compact JWS) |
| Sync with invalid JWT signature | 400 (JWS decode error) |
| Sync with wrong orgId | 400 (Access denied) |
| Sync with valid JWT + matching storeId | Success (not 400) |
| User B cannot sync with User A's org | 400 (Access denied) |

### Test Flow

```typescript
// 1. Signup creates user + org via databaseHooks
const res = await SELF.fetch('/api/auth/sign-up/email', {
  method: 'POST',
  body: JSON.stringify({ email, password, name })
})
const cookie = res.headers.get('set-cookie')

// 2. Get user info via /me endpoint
const me = await SELF.fetch('/api/auth/me', {
  headers: { Cookie: cookie }
})

// 3. Test org access
const org = await SELF.fetch(`/api/org/${orgId}`, {
  headers: { Cookie: cookie }
})
```

## Local Development

```bash
# 1. Create .dev.vars
GOOGLE_CLIENT_ID=your-client-id
GOOGLE_CLIENT_SECRET=your-client-secret
BETTER_AUTH_SECRET=random-32-char-string
BETTER_AUTH_URL=http://localhost:3000

# 2. Apply migrations
bun run db:migrate:local

# 3. Run
bun run dev
```

Google OAuth redirect URI: `http://localhost:3000/api/auth/callback/google`

## Production

```bash
# 1. Set secrets
wrangler secret put GOOGLE_CLIENT_ID
wrangler secret put GOOGLE_CLIENT_SECRET
wrangler secret put BETTER_AUTH_SECRET
wrangler secret put BETTER_AUTH_URL

# 2. Apply migrations
bun run db:migrate:remote

# 3. Deploy
bun run deploy
```

Google OAuth redirect URI: `https://your-domain.workers.dev/api/auth/callback/google`

## Security

- [x] HttpOnly, Secure, SameSite cookies
- [x] Org-scoped sync (storeId = organizationId)
- [x] JWT + JWKS validation (EdDSA Ed25519)
- [x] Short-lived JWTs (1h)
- [x] Router-level auth (`beforeLoad`)
- [x] Server-side org validation via JWT claims
- [ ] Token refresh before expiration
- [ ] Clear local data on logout
- [ ] Handle 401 on reconnect
